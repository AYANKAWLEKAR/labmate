"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool";
exports.ids = ["vendor-chunks/pg-pool"];
exports.modules = {

/***/ "(rsc)/../database/node_modules/pg-pool/index.js":
/*!*************************************************!*\
  !*** ../database/node_modules/pg-pool/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst NOOP = function() {};\nconst removeWhere = (list, predicate)=>{\n    const i = list.findIndex(predicate);\n    return i === -1 ? undefined : list.splice(i, 1)[0];\n};\nclass IdleItem {\n    constructor(client, idleListener, timeoutId){\n        this.client = client;\n        this.idleListener = idleListener;\n        this.timeoutId = timeoutId;\n    }\n}\nclass PendingItem {\n    constructor(callback){\n        this.callback = callback;\n    }\n}\nfunction throwOnDoubleRelease() {\n    throw new Error(\"Release called on client which has already been released to the pool.\");\n}\nfunction promisify(Promise, callback) {\n    if (callback) {\n        return {\n            callback: callback,\n            result: undefined\n        };\n    }\n    let rej;\n    let res;\n    const cb = function(err, client) {\n        err ? rej(err) : res(client);\n    };\n    const result = new Promise(function(resolve, reject) {\n        res = resolve;\n        rej = reject;\n    }).catch((err)=>{\n        // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n        // application that created the query\n        Error.captureStackTrace(err);\n        throw err;\n    });\n    return {\n        callback: cb,\n        result: result\n    };\n}\nfunction makeIdleListener(pool, client) {\n    return function idleListener(err) {\n        err.client = client;\n        client.removeListener(\"error\", idleListener);\n        client.on(\"error\", ()=>{\n            pool.log(\"additional client error after disconnection due to error\", err);\n        });\n        pool._remove(client);\n        // TODO - document that once the pool emits an error\n        // the client has already been closed & purged and is unusable\n        pool.emit(\"error\", err, client);\n    };\n}\nclass Pool extends EventEmitter {\n    constructor(options, Client){\n        super();\n        this.options = Object.assign({}, options);\n        if (options != null && \"password\" in options) {\n            // \"hiding\" the password so it doesn't show up in stack traces\n            // or if the client is console.logged\n            Object.defineProperty(this.options, \"password\", {\n                configurable: true,\n                enumerable: false,\n                writable: true,\n                value: options.password\n            });\n        }\n        if (options != null && options.ssl && options.ssl.key) {\n            // \"hiding\" the ssl->key so it doesn't show up in stack traces\n            // or if the client is console.logged\n            Object.defineProperty(this.options.ssl, \"key\", {\n                enumerable: false\n            });\n        }\n        this.options.max = this.options.max || this.options.poolSize || 10;\n        this.options.min = this.options.min || 0;\n        this.options.maxUses = this.options.maxUses || Infinity;\n        this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;\n        this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;\n        this.log = this.options.log || function() {};\n        this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(rsc)/../database/node_modules/pg/lib/index.js\").Client);\n        this.Promise = this.options.Promise || global.Promise;\n        if (typeof this.options.idleTimeoutMillis === \"undefined\") {\n            this.options.idleTimeoutMillis = 10000;\n        }\n        this._clients = [];\n        this._idle = [];\n        this._expired = new WeakSet();\n        this._pendingQueue = [];\n        this._endCallback = undefined;\n        this.ending = false;\n        this.ended = false;\n    }\n    _isFull() {\n        return this._clients.length >= this.options.max;\n    }\n    _isAboveMin() {\n        return this._clients.length > this.options.min;\n    }\n    _pulseQueue() {\n        this.log(\"pulse queue\");\n        if (this.ended) {\n            this.log(\"pulse queue ended\");\n            return;\n        }\n        if (this.ending) {\n            this.log(\"pulse queue on ending\");\n            if (this._idle.length) {\n                this._idle.slice().map((item)=>{\n                    this._remove(item.client);\n                });\n            }\n            if (!this._clients.length) {\n                this.ended = true;\n                this._endCallback();\n            }\n            return;\n        }\n        // if we don't have any waiting, do nothing\n        if (!this._pendingQueue.length) {\n            this.log(\"no queued requests\");\n            return;\n        }\n        // if we don't have any idle clients and we have no more room do nothing\n        if (!this._idle.length && this._isFull()) {\n            return;\n        }\n        const pendingItem = this._pendingQueue.shift();\n        if (this._idle.length) {\n            const idleItem = this._idle.pop();\n            clearTimeout(idleItem.timeoutId);\n            const client = idleItem.client;\n            client.ref && client.ref();\n            const idleListener = idleItem.idleListener;\n            return this._acquireClient(client, pendingItem, idleListener, false);\n        }\n        if (!this._isFull()) {\n            return this.newClient(pendingItem);\n        }\n        throw new Error(\"unexpected condition\");\n    }\n    _remove(client, callback) {\n        const removed = removeWhere(this._idle, (item)=>item.client === client);\n        if (removed !== undefined) {\n            clearTimeout(removed.timeoutId);\n        }\n        this._clients = this._clients.filter((c)=>c !== client);\n        const context = this;\n        client.end(()=>{\n            context.emit(\"remove\", client);\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n    }\n    connect(cb) {\n        if (this.ending) {\n            const err = new Error(\"Cannot use a pool after calling end on the pool\");\n            return cb ? cb(err) : this.Promise.reject(err);\n        }\n        const response = promisify(this.Promise, cb);\n        const result = response.result;\n        // if we don't have to connect a new client, don't do so\n        if (this._isFull() || this._idle.length) {\n            // if we have idle clients schedule a pulse immediately\n            if (this._idle.length) {\n                process.nextTick(()=>this._pulseQueue());\n            }\n            if (!this.options.connectionTimeoutMillis) {\n                this._pendingQueue.push(new PendingItem(response.callback));\n                return result;\n            }\n            const queueCallback = (err, res, done)=>{\n                clearTimeout(tid);\n                response.callback(err, res, done);\n            };\n            const pendingItem = new PendingItem(queueCallback);\n            // set connection timeout on checking out an existing client\n            const tid = setTimeout(()=>{\n                // remove the callback from pending waiters because\n                // we're going to call it with a timeout error\n                removeWhere(this._pendingQueue, (i)=>i.callback === queueCallback);\n                pendingItem.timedOut = true;\n                response.callback(new Error(\"timeout exceeded when trying to connect\"));\n            }, this.options.connectionTimeoutMillis);\n            if (tid.unref) {\n                tid.unref();\n            }\n            this._pendingQueue.push(pendingItem);\n            return result;\n        }\n        this.newClient(new PendingItem(response.callback));\n        return result;\n    }\n    newClient(pendingItem) {\n        const client = new this.Client(this.options);\n        this._clients.push(client);\n        const idleListener = makeIdleListener(this, client);\n        this.log(\"checking client timeout\");\n        // connection timeout logic\n        let tid;\n        let timeoutHit = false;\n        if (this.options.connectionTimeoutMillis) {\n            tid = setTimeout(()=>{\n                this.log(\"ending client due to timeout\");\n                timeoutHit = true;\n                // force kill the node driver, and let libpq do its teardown\n                client.connection ? client.connection.stream.destroy() : client.end();\n            }, this.options.connectionTimeoutMillis);\n        }\n        this.log(\"connecting new client\");\n        client.connect((err)=>{\n            if (tid) {\n                clearTimeout(tid);\n            }\n            client.on(\"error\", idleListener);\n            if (err) {\n                this.log(\"client failed to connect\", err);\n                // remove the dead client from our list of clients\n                this._clients = this._clients.filter((c)=>c !== client);\n                if (timeoutHit) {\n                    err = new Error(\"Connection terminated due to connection timeout\", {\n                        cause: err\n                    });\n                }\n                // this client wonâ€™t be released, so move on immediately\n                this._pulseQueue();\n                if (!pendingItem.timedOut) {\n                    pendingItem.callback(err, undefined, NOOP);\n                }\n            } else {\n                this.log(\"new client connected\");\n                if (this.options.maxLifetimeSeconds !== 0) {\n                    const maxLifetimeTimeout = setTimeout(()=>{\n                        this.log(\"ending client due to expired lifetime\");\n                        this._expired.add(client);\n                        const idleIndex = this._idle.findIndex((idleItem)=>idleItem.client === client);\n                        if (idleIndex !== -1) {\n                            this._acquireClient(client, new PendingItem((err, client, clientRelease)=>clientRelease()), idleListener, false);\n                        }\n                    }, this.options.maxLifetimeSeconds * 1000);\n                    maxLifetimeTimeout.unref();\n                    client.once(\"end\", ()=>clearTimeout(maxLifetimeTimeout));\n                }\n                return this._acquireClient(client, pendingItem, idleListener, true);\n            }\n        });\n    }\n    // acquire a client for a pending work item\n    _acquireClient(client, pendingItem, idleListener, isNew) {\n        if (isNew) {\n            this.emit(\"connect\", client);\n        }\n        this.emit(\"acquire\", client);\n        client.release = this._releaseOnce(client, idleListener);\n        client.removeListener(\"error\", idleListener);\n        if (!pendingItem.timedOut) {\n            if (isNew && this.options.verify) {\n                this.options.verify(client, (err)=>{\n                    if (err) {\n                        client.release(err);\n                        return pendingItem.callback(err, undefined, NOOP);\n                    }\n                    pendingItem.callback(undefined, client, client.release);\n                });\n            } else {\n                pendingItem.callback(undefined, client, client.release);\n            }\n        } else {\n            if (isNew && this.options.verify) {\n                this.options.verify(client, client.release);\n            } else {\n                client.release();\n            }\n        }\n    }\n    // returns a function that wraps _release and throws if called more than once\n    _releaseOnce(client, idleListener) {\n        let released = false;\n        return (err)=>{\n            if (released) {\n                throwOnDoubleRelease();\n            }\n            released = true;\n            this._release(client, idleListener, err);\n        };\n    }\n    // release a client back to the poll, include an error\n    // to remove it from the pool\n    _release(client, idleListener, err) {\n        client.on(\"error\", idleListener);\n        client._poolUseCount = (client._poolUseCount || 0) + 1;\n        this.emit(\"release\", err, client);\n        // TODO(bmc): expose a proper, public interface _queryable and _ending\n        if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n            if (client._poolUseCount >= this.options.maxUses) {\n                this.log(\"remove expended client\");\n            }\n            return this._remove(client, this._pulseQueue.bind(this));\n        }\n        const isExpired = this._expired.has(client);\n        if (isExpired) {\n            this.log(\"remove expired client\");\n            this._expired.delete(client);\n            return this._remove(client, this._pulseQueue.bind(this));\n        }\n        // idle timeout\n        let tid;\n        if (this.options.idleTimeoutMillis && this._isAboveMin()) {\n            tid = setTimeout(()=>{\n                this.log(\"remove idle client\");\n                this._remove(client, this._pulseQueue.bind(this));\n            }, this.options.idleTimeoutMillis);\n            if (this.options.allowExitOnIdle) {\n                // allow Node to exit if this is all that's left\n                tid.unref();\n            }\n        }\n        if (this.options.allowExitOnIdle) {\n            client.unref();\n        }\n        this._idle.push(new IdleItem(client, idleListener, tid));\n        this._pulseQueue();\n    }\n    query(text, values, cb) {\n        // guard clause against passing a function as the first parameter\n        if (typeof text === \"function\") {\n            const response = promisify(this.Promise, text);\n            setImmediate(function() {\n                return response.callback(new Error(\"Passing a function as the first parameter to pool.query is not supported\"));\n            });\n            return response.result;\n        }\n        // allow plain text query without values\n        if (typeof values === \"function\") {\n            cb = values;\n            values = undefined;\n        }\n        const response = promisify(this.Promise, cb);\n        cb = response.callback;\n        this.connect((err, client)=>{\n            if (err) {\n                return cb(err);\n            }\n            let clientReleased = false;\n            const onError = (err)=>{\n                if (clientReleased) {\n                    return;\n                }\n                clientReleased = true;\n                client.release(err);\n                cb(err);\n            };\n            client.once(\"error\", onError);\n            this.log(\"dispatching query\");\n            try {\n                client.query(text, values, (err, res)=>{\n                    this.log(\"query dispatched\");\n                    client.removeListener(\"error\", onError);\n                    if (clientReleased) {\n                        return;\n                    }\n                    clientReleased = true;\n                    client.release(err);\n                    if (err) {\n                        return cb(err);\n                    }\n                    return cb(undefined, res);\n                });\n            } catch (err) {\n                client.release(err);\n                return cb(err);\n            }\n        });\n        return response.result;\n    }\n    end(cb) {\n        this.log(\"ending\");\n        if (this.ending) {\n            const err = new Error(\"Called end on pool more than once\");\n            return cb ? cb(err) : this.Promise.reject(err);\n        }\n        this.ending = true;\n        const promised = promisify(this.Promise, cb);\n        this._endCallback = promised.callback;\n        this._pulseQueue();\n        return promised.result;\n    }\n    get waitingCount() {\n        return this._pendingQueue.length;\n    }\n    get idleCount() {\n        return this._idle.length;\n    }\n    get expiredCount() {\n        return this._clients.reduce((acc, client)=>acc + (this._expired.has(client) ? 1 : 0), 0);\n    }\n    get totalCount() {\n        return this._clients.length;\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vZGF0YWJhc2Uvbm9kZV9tb2R1bGVzL3BnLXBvb2wvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNQSxlQUFlQywwREFBOEI7QUFFbkQsTUFBTUMsT0FBTyxZQUFhO0FBRTFCLE1BQU1DLGNBQWMsQ0FBQ0MsTUFBTUM7SUFDekIsTUFBTUMsSUFBSUYsS0FBS0csU0FBUyxDQUFDRjtJQUV6QixPQUFPQyxNQUFNLENBQUMsSUFBSUUsWUFBWUosS0FBS0ssTUFBTSxDQUFDSCxHQUFHLEVBQUUsQ0FBQyxFQUFFO0FBQ3BEO0FBRUEsTUFBTUk7SUFDSkMsWUFBWUMsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLFNBQVMsQ0FBRTtRQUMzQyxJQUFJLENBQUNGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ25CO0FBQ0Y7QUFFQSxNQUFNQztJQUNKSixZQUFZSyxRQUFRLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO0lBQ2xCO0FBQ0Y7QUFFQSxTQUFTQztJQUNQLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQUVBLFNBQVNDLFVBQVVDLE9BQU8sRUFBRUosUUFBUTtJQUNsQyxJQUFJQSxVQUFVO1FBQ1osT0FBTztZQUFFQSxVQUFVQTtZQUFVSyxRQUFRYjtRQUFVO0lBQ2pEO0lBQ0EsSUFBSWM7SUFDSixJQUFJQztJQUNKLE1BQU1DLEtBQUssU0FBVUMsR0FBRyxFQUFFYixNQUFNO1FBQzlCYSxNQUFNSCxJQUFJRyxPQUFPRixJQUFJWDtJQUN2QjtJQUNBLE1BQU1TLFNBQVMsSUFBSUQsUUFBUSxTQUFVTSxPQUFPLEVBQUVDLE1BQU07UUFDbERKLE1BQU1HO1FBQ05KLE1BQU1LO0lBQ1IsR0FBR0MsS0FBSyxDQUFDLENBQUNIO1FBQ1IsMkZBQTJGO1FBQzNGLHFDQUFxQztRQUNyQ1AsTUFBTVcsaUJBQWlCLENBQUNKO1FBQ3hCLE1BQU1BO0lBQ1I7SUFDQSxPQUFPO1FBQUVULFVBQVVRO1FBQUlILFFBQVFBO0lBQU87QUFDeEM7QUFFQSxTQUFTUyxpQkFBaUJDLElBQUksRUFBRW5CLE1BQU07SUFDcEMsT0FBTyxTQUFTQyxhQUFhWSxHQUFHO1FBQzlCQSxJQUFJYixNQUFNLEdBQUdBO1FBRWJBLE9BQU9vQixjQUFjLENBQUMsU0FBU25CO1FBQy9CRCxPQUFPcUIsRUFBRSxDQUFDLFNBQVM7WUFDakJGLEtBQUtHLEdBQUcsQ0FBQyw0REFBNERUO1FBQ3ZFO1FBQ0FNLEtBQUtJLE9BQU8sQ0FBQ3ZCO1FBQ2Isb0RBQW9EO1FBQ3BELDhEQUE4RDtRQUM5RG1CLEtBQUtLLElBQUksQ0FBQyxTQUFTWCxLQUFLYjtJQUMxQjtBQUNGO0FBRUEsTUFBTXlCLGFBQWFyQztJQUNqQlcsWUFBWTJCLE9BQU8sRUFBRUMsTUFBTSxDQUFFO1FBQzNCLEtBQUs7UUFDTCxJQUFJLENBQUNELE9BQU8sR0FBR0UsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0g7UUFFakMsSUFBSUEsV0FBVyxRQUFRLGNBQWNBLFNBQVM7WUFDNUMsOERBQThEO1lBQzlELHFDQUFxQztZQUNyQ0UsT0FBT0UsY0FBYyxDQUFDLElBQUksQ0FBQ0osT0FBTyxFQUFFLFlBQVk7Z0JBQzlDSyxjQUFjO2dCQUNkQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWQyxPQUFPUixRQUFRUyxRQUFRO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJVCxXQUFXLFFBQVFBLFFBQVFVLEdBQUcsSUFBSVYsUUFBUVUsR0FBRyxDQUFDQyxHQUFHLEVBQUU7WUFDckQsOERBQThEO1lBQzlELHFDQUFxQztZQUNyQ1QsT0FBT0UsY0FBYyxDQUFDLElBQUksQ0FBQ0osT0FBTyxDQUFDVSxHQUFHLEVBQUUsT0FBTztnQkFDN0NKLFlBQVk7WUFDZDtRQUNGO1FBRUEsSUFBSSxDQUFDTixPQUFPLENBQUNZLEdBQUcsR0FBRyxJQUFJLENBQUNaLE9BQU8sQ0FBQ1ksR0FBRyxJQUFJLElBQUksQ0FBQ1osT0FBTyxDQUFDYSxRQUFRLElBQUk7UUFDaEUsSUFBSSxDQUFDYixPQUFPLENBQUNjLEdBQUcsR0FBRyxJQUFJLENBQUNkLE9BQU8sQ0FBQ2MsR0FBRyxJQUFJO1FBQ3ZDLElBQUksQ0FBQ2QsT0FBTyxDQUFDZSxPQUFPLEdBQUcsSUFBSSxDQUFDZixPQUFPLENBQUNlLE9BQU8sSUFBSUM7UUFDL0MsSUFBSSxDQUFDaEIsT0FBTyxDQUFDaUIsZUFBZSxHQUFHLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ2lCLGVBQWUsSUFBSTtRQUMvRCxJQUFJLENBQUNqQixPQUFPLENBQUNrQixrQkFBa0IsR0FBRyxJQUFJLENBQUNsQixPQUFPLENBQUNrQixrQkFBa0IsSUFBSTtRQUNyRSxJQUFJLENBQUN0QixHQUFHLEdBQUcsSUFBSSxDQUFDSSxPQUFPLENBQUNKLEdBQUcsSUFBSSxZQUFhO1FBQzVDLElBQUksQ0FBQ0ssTUFBTSxHQUFHLElBQUksQ0FBQ0QsT0FBTyxDQUFDQyxNQUFNLElBQUlBLFVBQVV0Qyx3RkFBb0I7UUFDbkUsSUFBSSxDQUFDbUIsT0FBTyxHQUFHLElBQUksQ0FBQ2tCLE9BQU8sQ0FBQ2xCLE9BQU8sSUFBSXFDLE9BQU9yQyxPQUFPO1FBRXJELElBQUksT0FBTyxJQUFJLENBQUNrQixPQUFPLENBQUNvQixpQkFBaUIsS0FBSyxhQUFhO1lBQ3pELElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ29CLGlCQUFpQixHQUFHO1FBQ25DO1FBRUEsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSUM7UUFDcEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLFlBQVksR0FBR3hEO1FBQ3BCLElBQUksQ0FBQ3lELE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2Y7SUFFQUMsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDUixRQUFRLENBQUNTLE1BQU0sSUFBSSxJQUFJLENBQUM5QixPQUFPLENBQUNZLEdBQUc7SUFDakQ7SUFFQW1CLGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQ1YsUUFBUSxDQUFDUyxNQUFNLEdBQUcsSUFBSSxDQUFDOUIsT0FBTyxDQUFDYyxHQUFHO0lBQ2hEO0lBRUFrQixjQUFjO1FBQ1osSUFBSSxDQUFDcEMsR0FBRyxDQUFDO1FBQ1QsSUFBSSxJQUFJLENBQUNnQyxLQUFLLEVBQUU7WUFDZCxJQUFJLENBQUNoQyxHQUFHLENBQUM7WUFDVDtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMrQixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMvQixHQUFHLENBQUM7WUFDVCxJQUFJLElBQUksQ0FBQzBCLEtBQUssQ0FBQ1EsTUFBTSxFQUFFO2dCQUNyQixJQUFJLENBQUNSLEtBQUssQ0FBQ1csS0FBSyxHQUFHQyxHQUFHLENBQUMsQ0FBQ0M7b0JBQ3RCLElBQUksQ0FBQ3RDLE9BQU8sQ0FBQ3NDLEtBQUs3RCxNQUFNO2dCQUMxQjtZQUNGO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQytDLFFBQVEsQ0FBQ1MsTUFBTSxFQUFFO2dCQUN6QixJQUFJLENBQUNGLEtBQUssR0FBRztnQkFDYixJQUFJLENBQUNGLFlBQVk7WUFDbkI7WUFDQTtRQUNGO1FBRUEsMkNBQTJDO1FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUNELGFBQWEsQ0FBQ0ssTUFBTSxFQUFFO1lBQzlCLElBQUksQ0FBQ2xDLEdBQUcsQ0FBQztZQUNUO1FBQ0Y7UUFDQSx3RUFBd0U7UUFDeEUsSUFBSSxDQUFDLElBQUksQ0FBQzBCLEtBQUssQ0FBQ1EsTUFBTSxJQUFJLElBQUksQ0FBQ0QsT0FBTyxJQUFJO1lBQ3hDO1FBQ0Y7UUFDQSxNQUFNTyxjQUFjLElBQUksQ0FBQ1gsYUFBYSxDQUFDWSxLQUFLO1FBQzVDLElBQUksSUFBSSxDQUFDZixLQUFLLENBQUNRLE1BQU0sRUFBRTtZQUNyQixNQUFNUSxXQUFXLElBQUksQ0FBQ2hCLEtBQUssQ0FBQ2lCLEdBQUc7WUFDL0JDLGFBQWFGLFNBQVM5RCxTQUFTO1lBQy9CLE1BQU1GLFNBQVNnRSxTQUFTaEUsTUFBTTtZQUM5QkEsT0FBT21FLEdBQUcsSUFBSW5FLE9BQU9tRSxHQUFHO1lBQ3hCLE1BQU1sRSxlQUFlK0QsU0FBUy9ELFlBQVk7WUFFMUMsT0FBTyxJQUFJLENBQUNtRSxjQUFjLENBQUNwRSxRQUFROEQsYUFBYTdELGNBQWM7UUFDaEU7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDc0QsT0FBTyxJQUFJO1lBQ25CLE9BQU8sSUFBSSxDQUFDYyxTQUFTLENBQUNQO1FBQ3hCO1FBQ0EsTUFBTSxJQUFJeEQsTUFBTTtJQUNsQjtJQUVBaUIsUUFBUXZCLE1BQU0sRUFBRUksUUFBUSxFQUFFO1FBQ3hCLE1BQU1rRSxVQUFVL0UsWUFBWSxJQUFJLENBQUN5RCxLQUFLLEVBQUUsQ0FBQ2EsT0FBU0EsS0FBSzdELE1BQU0sS0FBS0E7UUFFbEUsSUFBSXNFLFlBQVkxRSxXQUFXO1lBQ3pCc0UsYUFBYUksUUFBUXBFLFNBQVM7UUFDaEM7UUFFQSxJQUFJLENBQUM2QyxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUN3QixNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsTUFBTXhFO1FBQ2xELE1BQU15RSxVQUFVLElBQUk7UUFDcEJ6RSxPQUFPMEUsR0FBRyxDQUFDO1lBQ1RELFFBQVFqRCxJQUFJLENBQUMsVUFBVXhCO1lBRXZCLElBQUksT0FBT0ksYUFBYSxZQUFZO2dCQUNsQ0E7WUFDRjtRQUNGO0lBQ0Y7SUFFQXVFLFFBQVEvRCxFQUFFLEVBQUU7UUFDVixJQUFJLElBQUksQ0FBQ3lDLE1BQU0sRUFBRTtZQUNmLE1BQU14QyxNQUFNLElBQUlQLE1BQU07WUFDdEIsT0FBT00sS0FBS0EsR0FBR0MsT0FBTyxJQUFJLENBQUNMLE9BQU8sQ0FBQ08sTUFBTSxDQUFDRjtRQUM1QztRQUVBLE1BQU0rRCxXQUFXckUsVUFBVSxJQUFJLENBQUNDLE9BQU8sRUFBRUk7UUFDekMsTUFBTUgsU0FBU21FLFNBQVNuRSxNQUFNO1FBRTlCLHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQzhDLE9BQU8sTUFBTSxJQUFJLENBQUNQLEtBQUssQ0FBQ1EsTUFBTSxFQUFFO1lBQ3ZDLHVEQUF1RDtZQUN2RCxJQUFJLElBQUksQ0FBQ1IsS0FBSyxDQUFDUSxNQUFNLEVBQUU7Z0JBQ3JCcUIsUUFBUUMsUUFBUSxDQUFDLElBQU0sSUFBSSxDQUFDcEIsV0FBVztZQUN6QztZQUVBLElBQUksQ0FBQyxJQUFJLENBQUNoQyxPQUFPLENBQUNxRCx1QkFBdUIsRUFBRTtnQkFDekMsSUFBSSxDQUFDNUIsYUFBYSxDQUFDNkIsSUFBSSxDQUFDLElBQUk3RSxZQUFZeUUsU0FBU3hFLFFBQVE7Z0JBQ3pELE9BQU9LO1lBQ1Q7WUFFQSxNQUFNd0UsZ0JBQWdCLENBQUNwRSxLQUFLRixLQUFLdUU7Z0JBQy9CaEIsYUFBYWlCO2dCQUNiUCxTQUFTeEUsUUFBUSxDQUFDUyxLQUFLRixLQUFLdUU7WUFDOUI7WUFFQSxNQUFNcEIsY0FBYyxJQUFJM0QsWUFBWThFO1lBRXBDLDREQUE0RDtZQUM1RCxNQUFNRSxNQUFNQyxXQUFXO2dCQUNyQixtREFBbUQ7Z0JBQ25ELDhDQUE4QztnQkFDOUM3RixZQUFZLElBQUksQ0FBQzRELGFBQWEsRUFBRSxDQUFDekQsSUFBTUEsRUFBRVUsUUFBUSxLQUFLNkU7Z0JBQ3REbkIsWUFBWXVCLFFBQVEsR0FBRztnQkFDdkJULFNBQVN4RSxRQUFRLENBQUMsSUFBSUUsTUFBTTtZQUM5QixHQUFHLElBQUksQ0FBQ29CLE9BQU8sQ0FBQ3FELHVCQUF1QjtZQUV2QyxJQUFJSSxJQUFJRyxLQUFLLEVBQUU7Z0JBQ2JILElBQUlHLEtBQUs7WUFDWDtZQUVBLElBQUksQ0FBQ25DLGFBQWEsQ0FBQzZCLElBQUksQ0FBQ2xCO1lBQ3hCLE9BQU9yRDtRQUNUO1FBRUEsSUFBSSxDQUFDNEQsU0FBUyxDQUFDLElBQUlsRSxZQUFZeUUsU0FBU3hFLFFBQVE7UUFFaEQsT0FBT0s7SUFDVDtJQUVBNEQsVUFBVVAsV0FBVyxFQUFFO1FBQ3JCLE1BQU05RCxTQUFTLElBQUksSUFBSSxDQUFDMkIsTUFBTSxDQUFDLElBQUksQ0FBQ0QsT0FBTztRQUMzQyxJQUFJLENBQUNxQixRQUFRLENBQUNpQyxJQUFJLENBQUNoRjtRQUNuQixNQUFNQyxlQUFlaUIsaUJBQWlCLElBQUksRUFBRWxCO1FBRTVDLElBQUksQ0FBQ3NCLEdBQUcsQ0FBQztRQUVULDJCQUEyQjtRQUMzQixJQUFJNkQ7UUFDSixJQUFJSSxhQUFhO1FBQ2pCLElBQUksSUFBSSxDQUFDN0QsT0FBTyxDQUFDcUQsdUJBQXVCLEVBQUU7WUFDeENJLE1BQU1DLFdBQVc7Z0JBQ2YsSUFBSSxDQUFDOUQsR0FBRyxDQUFDO2dCQUNUaUUsYUFBYTtnQkFDYiw0REFBNEQ7Z0JBQzVEdkYsT0FBT3dGLFVBQVUsR0FBR3hGLE9BQU93RixVQUFVLENBQUNDLE1BQU0sQ0FBQ0MsT0FBTyxLQUFLMUYsT0FBTzBFLEdBQUc7WUFDckUsR0FBRyxJQUFJLENBQUNoRCxPQUFPLENBQUNxRCx1QkFBdUI7UUFDekM7UUFFQSxJQUFJLENBQUN6RCxHQUFHLENBQUM7UUFDVHRCLE9BQU8yRSxPQUFPLENBQUMsQ0FBQzlEO1lBQ2QsSUFBSXNFLEtBQUs7Z0JBQ1BqQixhQUFhaUI7WUFDZjtZQUNBbkYsT0FBT3FCLEVBQUUsQ0FBQyxTQUFTcEI7WUFDbkIsSUFBSVksS0FBSztnQkFDUCxJQUFJLENBQUNTLEdBQUcsQ0FBQyw0QkFBNEJUO2dCQUNyQyxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQ2tDLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVEsQ0FBQ3dCLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxNQUFNeEU7Z0JBQ2xELElBQUl1RixZQUFZO29CQUNkMUUsTUFBTSxJQUFJUCxNQUFNLG1EQUFtRDt3QkFBRXFGLE9BQU85RTtvQkFBSTtnQkFDbEY7Z0JBRUEsd0RBQXdEO2dCQUN4RCxJQUFJLENBQUM2QyxXQUFXO2dCQUVoQixJQUFJLENBQUNJLFlBQVl1QixRQUFRLEVBQUU7b0JBQ3pCdkIsWUFBWTFELFFBQVEsQ0FBQ1MsS0FBS2pCLFdBQVdOO2dCQUN2QztZQUNGLE9BQU87Z0JBQ0wsSUFBSSxDQUFDZ0MsR0FBRyxDQUFDO2dCQUVULElBQUksSUFBSSxDQUFDSSxPQUFPLENBQUNrQixrQkFBa0IsS0FBSyxHQUFHO29CQUN6QyxNQUFNZ0QscUJBQXFCUixXQUFXO3dCQUNwQyxJQUFJLENBQUM5RCxHQUFHLENBQUM7d0JBQ1QsSUFBSSxDQUFDMkIsUUFBUSxDQUFDNEMsR0FBRyxDQUFDN0Y7d0JBQ2xCLE1BQU04RixZQUFZLElBQUksQ0FBQzlDLEtBQUssQ0FBQ3JELFNBQVMsQ0FBQyxDQUFDcUUsV0FBYUEsU0FBU2hFLE1BQU0sS0FBS0E7d0JBQ3pFLElBQUk4RixjQUFjLENBQUMsR0FBRzs0QkFDcEIsSUFBSSxDQUFDMUIsY0FBYyxDQUNqQnBFLFFBQ0EsSUFBSUcsWUFBWSxDQUFDVSxLQUFLYixRQUFRK0YsZ0JBQWtCQSxrQkFDaEQ5RixjQUNBO3dCQUVKO29CQUNGLEdBQUcsSUFBSSxDQUFDeUIsT0FBTyxDQUFDa0Isa0JBQWtCLEdBQUc7b0JBRXJDZ0QsbUJBQW1CTixLQUFLO29CQUN4QnRGLE9BQU9nRyxJQUFJLENBQUMsT0FBTyxJQUFNOUIsYUFBYTBCO2dCQUN4QztnQkFFQSxPQUFPLElBQUksQ0FBQ3hCLGNBQWMsQ0FBQ3BFLFFBQVE4RCxhQUFhN0QsY0FBYztZQUNoRTtRQUNGO0lBQ0Y7SUFFQSwyQ0FBMkM7SUFDM0NtRSxlQUFlcEUsTUFBTSxFQUFFOEQsV0FBVyxFQUFFN0QsWUFBWSxFQUFFZ0csS0FBSyxFQUFFO1FBQ3ZELElBQUlBLE9BQU87WUFDVCxJQUFJLENBQUN6RSxJQUFJLENBQUMsV0FBV3hCO1FBQ3ZCO1FBRUEsSUFBSSxDQUFDd0IsSUFBSSxDQUFDLFdBQVd4QjtRQUVyQkEsT0FBT2tHLE9BQU8sR0FBRyxJQUFJLENBQUNDLFlBQVksQ0FBQ25HLFFBQVFDO1FBRTNDRCxPQUFPb0IsY0FBYyxDQUFDLFNBQVNuQjtRQUUvQixJQUFJLENBQUM2RCxZQUFZdUIsUUFBUSxFQUFFO1lBQ3pCLElBQUlZLFNBQVMsSUFBSSxDQUFDdkUsT0FBTyxDQUFDMEUsTUFBTSxFQUFFO2dCQUNoQyxJQUFJLENBQUMxRSxPQUFPLENBQUMwRSxNQUFNLENBQUNwRyxRQUFRLENBQUNhO29CQUMzQixJQUFJQSxLQUFLO3dCQUNQYixPQUFPa0csT0FBTyxDQUFDckY7d0JBQ2YsT0FBT2lELFlBQVkxRCxRQUFRLENBQUNTLEtBQUtqQixXQUFXTjtvQkFDOUM7b0JBRUF3RSxZQUFZMUQsUUFBUSxDQUFDUixXQUFXSSxRQUFRQSxPQUFPa0csT0FBTztnQkFDeEQ7WUFDRixPQUFPO2dCQUNMcEMsWUFBWTFELFFBQVEsQ0FBQ1IsV0FBV0ksUUFBUUEsT0FBT2tHLE9BQU87WUFDeEQ7UUFDRixPQUFPO1lBQ0wsSUFBSUQsU0FBUyxJQUFJLENBQUN2RSxPQUFPLENBQUMwRSxNQUFNLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQzFFLE9BQU8sQ0FBQzBFLE1BQU0sQ0FBQ3BHLFFBQVFBLE9BQU9rRyxPQUFPO1lBQzVDLE9BQU87Z0JBQ0xsRyxPQUFPa0csT0FBTztZQUNoQjtRQUNGO0lBQ0Y7SUFFQSw2RUFBNkU7SUFDN0VDLGFBQWFuRyxNQUFNLEVBQUVDLFlBQVksRUFBRTtRQUNqQyxJQUFJb0csV0FBVztRQUVmLE9BQU8sQ0FBQ3hGO1lBQ04sSUFBSXdGLFVBQVU7Z0JBQ1poRztZQUNGO1lBRUFnRyxXQUFXO1lBQ1gsSUFBSSxDQUFDQyxRQUFRLENBQUN0RyxRQUFRQyxjQUFjWTtRQUN0QztJQUNGO0lBRUEsc0RBQXNEO0lBQ3RELDZCQUE2QjtJQUM3QnlGLFNBQVN0RyxNQUFNLEVBQUVDLFlBQVksRUFBRVksR0FBRyxFQUFFO1FBQ2xDYixPQUFPcUIsRUFBRSxDQUFDLFNBQVNwQjtRQUVuQkQsT0FBT3VHLGFBQWEsR0FBRyxDQUFDdkcsT0FBT3VHLGFBQWEsSUFBSSxLQUFLO1FBRXJELElBQUksQ0FBQy9FLElBQUksQ0FBQyxXQUFXWCxLQUFLYjtRQUUxQixzRUFBc0U7UUFDdEUsSUFBSWEsT0FBTyxJQUFJLENBQUN3QyxNQUFNLElBQUksQ0FBQ3JELE9BQU93RyxVQUFVLElBQUl4RyxPQUFPeUcsT0FBTyxJQUFJekcsT0FBT3VHLGFBQWEsSUFBSSxJQUFJLENBQUM3RSxPQUFPLENBQUNlLE9BQU8sRUFBRTtZQUM5RyxJQUFJekMsT0FBT3VHLGFBQWEsSUFBSSxJQUFJLENBQUM3RSxPQUFPLENBQUNlLE9BQU8sRUFBRTtnQkFDaEQsSUFBSSxDQUFDbkIsR0FBRyxDQUFDO1lBQ1g7WUFFQSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDdkIsUUFBUSxJQUFJLENBQUMwRCxXQUFXLENBQUNnRCxJQUFJLENBQUMsSUFBSTtRQUN4RDtRQUVBLE1BQU1DLFlBQVksSUFBSSxDQUFDMUQsUUFBUSxDQUFDMkQsR0FBRyxDQUFDNUc7UUFDcEMsSUFBSTJHLFdBQVc7WUFDYixJQUFJLENBQUNyRixHQUFHLENBQUM7WUFDVCxJQUFJLENBQUMyQixRQUFRLENBQUM0RCxNQUFNLENBQUM3RztZQUNyQixPQUFPLElBQUksQ0FBQ3VCLE9BQU8sQ0FBQ3ZCLFFBQVEsSUFBSSxDQUFDMEQsV0FBVyxDQUFDZ0QsSUFBSSxDQUFDLElBQUk7UUFDeEQ7UUFFQSxlQUFlO1FBQ2YsSUFBSXZCO1FBQ0osSUFBSSxJQUFJLENBQUN6RCxPQUFPLENBQUNvQixpQkFBaUIsSUFBSSxJQUFJLENBQUNXLFdBQVcsSUFBSTtZQUN4RDBCLE1BQU1DLFdBQVc7Z0JBQ2YsSUFBSSxDQUFDOUQsR0FBRyxDQUFDO2dCQUNULElBQUksQ0FBQ0MsT0FBTyxDQUFDdkIsUUFBUSxJQUFJLENBQUMwRCxXQUFXLENBQUNnRCxJQUFJLENBQUMsSUFBSTtZQUNqRCxHQUFHLElBQUksQ0FBQ2hGLE9BQU8sQ0FBQ29CLGlCQUFpQjtZQUVqQyxJQUFJLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ2lCLGVBQWUsRUFBRTtnQkFDaEMsZ0RBQWdEO2dCQUNoRHdDLElBQUlHLEtBQUs7WUFDWDtRQUNGO1FBRUEsSUFBSSxJQUFJLENBQUM1RCxPQUFPLENBQUNpQixlQUFlLEVBQUU7WUFDaEMzQyxPQUFPc0YsS0FBSztRQUNkO1FBRUEsSUFBSSxDQUFDdEMsS0FBSyxDQUFDZ0MsSUFBSSxDQUFDLElBQUlsRixTQUFTRSxRQUFRQyxjQUFja0Y7UUFDbkQsSUFBSSxDQUFDekIsV0FBVztJQUNsQjtJQUVBb0QsTUFBTUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVwRyxFQUFFLEVBQUU7UUFDdEIsaUVBQWlFO1FBQ2pFLElBQUksT0FBT21HLFNBQVMsWUFBWTtZQUM5QixNQUFNbkMsV0FBV3JFLFVBQVUsSUFBSSxDQUFDQyxPQUFPLEVBQUV1RztZQUN6Q0UsYUFBYTtnQkFDWCxPQUFPckMsU0FBU3hFLFFBQVEsQ0FBQyxJQUFJRSxNQUFNO1lBQ3JDO1lBQ0EsT0FBT3NFLFNBQVNuRSxNQUFNO1FBQ3hCO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUksT0FBT3VHLFdBQVcsWUFBWTtZQUNoQ3BHLEtBQUtvRztZQUNMQSxTQUFTcEg7UUFDWDtRQUNBLE1BQU1nRixXQUFXckUsVUFBVSxJQUFJLENBQUNDLE9BQU8sRUFBRUk7UUFDekNBLEtBQUtnRSxTQUFTeEUsUUFBUTtRQUV0QixJQUFJLENBQUN1RSxPQUFPLENBQUMsQ0FBQzlELEtBQUtiO1lBQ2pCLElBQUlhLEtBQUs7Z0JBQ1AsT0FBT0QsR0FBR0M7WUFDWjtZQUVBLElBQUlxRyxpQkFBaUI7WUFDckIsTUFBTUMsVUFBVSxDQUFDdEc7Z0JBQ2YsSUFBSXFHLGdCQUFnQjtvQkFDbEI7Z0JBQ0Y7Z0JBQ0FBLGlCQUFpQjtnQkFDakJsSCxPQUFPa0csT0FBTyxDQUFDckY7Z0JBQ2ZELEdBQUdDO1lBQ0w7WUFFQWIsT0FBT2dHLElBQUksQ0FBQyxTQUFTbUI7WUFDckIsSUFBSSxDQUFDN0YsR0FBRyxDQUFDO1lBQ1QsSUFBSTtnQkFDRnRCLE9BQU84RyxLQUFLLENBQUNDLE1BQU1DLFFBQVEsQ0FBQ25HLEtBQUtGO29CQUMvQixJQUFJLENBQUNXLEdBQUcsQ0FBQztvQkFDVHRCLE9BQU9vQixjQUFjLENBQUMsU0FBUytGO29CQUMvQixJQUFJRCxnQkFBZ0I7d0JBQ2xCO29CQUNGO29CQUNBQSxpQkFBaUI7b0JBQ2pCbEgsT0FBT2tHLE9BQU8sQ0FBQ3JGO29CQUNmLElBQUlBLEtBQUs7d0JBQ1AsT0FBT0QsR0FBR0M7b0JBQ1o7b0JBQ0EsT0FBT0QsR0FBR2hCLFdBQVdlO2dCQUN2QjtZQUNGLEVBQUUsT0FBT0UsS0FBSztnQkFDWmIsT0FBT2tHLE9BQU8sQ0FBQ3JGO2dCQUNmLE9BQU9ELEdBQUdDO1lBQ1o7UUFDRjtRQUNBLE9BQU8rRCxTQUFTbkUsTUFBTTtJQUN4QjtJQUVBaUUsSUFBSTlELEVBQUUsRUFBRTtRQUNOLElBQUksQ0FBQ1UsR0FBRyxDQUFDO1FBQ1QsSUFBSSxJQUFJLENBQUMrQixNQUFNLEVBQUU7WUFDZixNQUFNeEMsTUFBTSxJQUFJUCxNQUFNO1lBQ3RCLE9BQU9NLEtBQUtBLEdBQUdDLE9BQU8sSUFBSSxDQUFDTCxPQUFPLENBQUNPLE1BQU0sQ0FBQ0Y7UUFDNUM7UUFDQSxJQUFJLENBQUN3QyxNQUFNLEdBQUc7UUFDZCxNQUFNK0QsV0FBVzdHLFVBQVUsSUFBSSxDQUFDQyxPQUFPLEVBQUVJO1FBQ3pDLElBQUksQ0FBQ3dDLFlBQVksR0FBR2dFLFNBQVNoSCxRQUFRO1FBQ3JDLElBQUksQ0FBQ3NELFdBQVc7UUFDaEIsT0FBTzBELFNBQVMzRyxNQUFNO0lBQ3hCO0lBRUEsSUFBSTRHLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUNsRSxhQUFhLENBQUNLLE1BQU07SUFDbEM7SUFFQSxJQUFJOEQsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDdEUsS0FBSyxDQUFDUSxNQUFNO0lBQzFCO0lBRUEsSUFBSStELGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUN4RSxRQUFRLENBQUN5RSxNQUFNLENBQUMsQ0FBQ0MsS0FBS3pILFNBQVd5SCxNQUFPLEtBQUksQ0FBQ3hFLFFBQVEsQ0FBQzJELEdBQUcsQ0FBQzVHLFVBQVUsSUFBSSxJQUFJO0lBQzFGO0lBRUEsSUFBSTBILGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQzNFLFFBQVEsQ0FBQ1MsTUFBTTtJQUM3QjtBQUNGO0FBQ0FtRSxPQUFPQyxPQUFPLEdBQUduRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYm1hdGUtd2ViLy4uL2RhdGFiYXNlL25vZGVfbW9kdWxlcy9wZy1wb29sL2luZGV4LmpzP2MwNWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcblxuY29uc3QgTk9PUCA9IGZ1bmN0aW9uICgpIHt9XG5cbmNvbnN0IHJlbW92ZVdoZXJlID0gKGxpc3QsIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCBpID0gbGlzdC5maW5kSW5kZXgocHJlZGljYXRlKVxuXG4gIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IGxpc3Quc3BsaWNlKGksIDEpWzBdXG59XG5cbmNsYXNzIElkbGVJdGVtIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpZGxlTGlzdGVuZXIsIHRpbWVvdXRJZCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5pZGxlTGlzdGVuZXIgPSBpZGxlTGlzdGVuZXJcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHRpbWVvdXRJZFxuICB9XG59XG5cbmNsYXNzIFBlbmRpbmdJdGVtIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd09uRG91YmxlUmVsZWFzZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWxlYXNlIGNhbGxlZCBvbiBjbGllbnQgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiByZWxlYXNlZCB0byB0aGUgcG9vbC4nKVxufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoUHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHsgY2FsbGJhY2s6IGNhbGxiYWNrLCByZXN1bHQ6IHVuZGVmaW5lZCB9XG4gIH1cbiAgbGV0IHJlalxuICBsZXQgcmVzXG4gIGNvbnN0IGNiID0gZnVuY3Rpb24gKGVyciwgY2xpZW50KSB7XG4gICAgZXJyID8gcmVqKGVycikgOiByZXMoY2xpZW50KVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXMgPSByZXNvbHZlXG4gICAgcmVqID0gcmVqZWN0XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAvLyByZXBsYWNlIHRoZSBzdGFjayB0cmFjZSB0aGF0IGxlYWRzIHRvIGBUQ1Aub25TdHJlYW1SZWFkYCB3aXRoIG9uZSB0aGF0IGxlYWRzIGJhY2sgdG8gdGhlXG4gICAgLy8gYXBwbGljYXRpb24gdGhhdCBjcmVhdGVkIHRoZSBxdWVyeVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycilcbiAgICB0aHJvdyBlcnJcbiAgfSlcbiAgcmV0dXJuIHsgY2FsbGJhY2s6IGNiLCByZXN1bHQ6IHJlc3VsdCB9XG59XG5cbmZ1bmN0aW9uIG1ha2VJZGxlTGlzdGVuZXIocG9vbCwgY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpZGxlTGlzdGVuZXIoZXJyKSB7XG4gICAgZXJyLmNsaWVudCA9IGNsaWVudFxuXG4gICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcbiAgICBjbGllbnQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbC5sb2coJ2FkZGl0aW9uYWwgY2xpZW50IGVycm9yIGFmdGVyIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGVycm9yJywgZXJyKVxuICAgIH0pXG4gICAgcG9vbC5fcmVtb3ZlKGNsaWVudClcbiAgICAvLyBUT0RPIC0gZG9jdW1lbnQgdGhhdCBvbmNlIHRoZSBwb29sIGVtaXRzIGFuIGVycm9yXG4gICAgLy8gdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCAmIHB1cmdlZCBhbmQgaXMgdW51c2FibGVcbiAgICBwb29sLmVtaXQoJ2Vycm9yJywgZXJyLCBjbGllbnQpXG4gIH1cbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIENsaWVudCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiAncGFzc3dvcmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIC8vIFwiaGlkaW5nXCIgdGhlIHBhc3N3b3JkIHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsICdwYXNzd29yZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLnBhc3N3b3JkLFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnNzbCAmJiBvcHRpb25zLnNzbC5rZXkpIHtcbiAgICAgIC8vIFwiaGlkaW5nXCIgdGhlIHNzbC0+a2V5IHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMuc3NsLCAna2V5Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLm1heCA9IHRoaXMub3B0aW9ucy5tYXggfHwgdGhpcy5vcHRpb25zLnBvb2xTaXplIHx8IDEwXG4gICAgdGhpcy5vcHRpb25zLm1pbiA9IHRoaXMub3B0aW9ucy5taW4gfHwgMFxuICAgIHRoaXMub3B0aW9ucy5tYXhVc2VzID0gdGhpcy5vcHRpb25zLm1heFVzZXMgfHwgSW5maW5pdHlcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlID0gdGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSB8fCBmYWxzZVxuICAgIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgPSB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzIHx8IDBcbiAgICB0aGlzLmxvZyA9IHRoaXMub3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24gKCkge31cbiAgICB0aGlzLkNsaWVudCA9IHRoaXMub3B0aW9ucy5DbGllbnQgfHwgQ2xpZW50IHx8IHJlcXVpcmUoJ3BnJykuQ2xpZW50XG4gICAgdGhpcy5Qcm9taXNlID0gdGhpcy5vcHRpb25zLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2VcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID0gMTAwMDBcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnRzID0gW11cbiAgICB0aGlzLl9pZGxlID0gW11cbiAgICB0aGlzLl9leHBpcmVkID0gbmV3IFdlYWtTZXQoKVxuICAgIHRoaXMuX3BlbmRpbmdRdWV1ZSA9IFtdXG4gICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlXG4gIH1cblxuICBfaXNGdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4XG4gIH1cblxuICBfaXNBYm92ZU1pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWluXG4gIH1cblxuICBfcHVsc2VRdWV1ZSgpIHtcbiAgICB0aGlzLmxvZygncHVsc2UgcXVldWUnKVxuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygncHVsc2UgcXVldWUgZW5kZWQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlIG9uIGVuZGluZycpXG4gICAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faWRsZS5zbGljZSgpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZShpdGVtLmNsaWVudClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fY2xpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgd2FpdGluZywgZG8gbm90aGluZ1xuICAgIGlmICghdGhpcy5fcGVuZGluZ1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ25vIHF1ZXVlZCByZXF1ZXN0cycpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgaWRsZSBjbGllbnRzIGFuZCB3ZSBoYXZlIG5vIG1vcmUgcm9vbSBkbyBub3RoaW5nXG4gICAgaWYgKCF0aGlzLl9pZGxlLmxlbmd0aCAmJiB0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gdGhpcy5fcGVuZGluZ1F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGlkbGVJdGVtID0gdGhpcy5faWRsZS5wb3AoKVxuICAgICAgY2xlYXJUaW1lb3V0KGlkbGVJdGVtLnRpbWVvdXRJZClcbiAgICAgIGNvbnN0IGNsaWVudCA9IGlkbGVJdGVtLmNsaWVudFxuICAgICAgY2xpZW50LnJlZiAmJiBjbGllbnQucmVmKClcbiAgICAgIGNvbnN0IGlkbGVMaXN0ZW5lciA9IGlkbGVJdGVtLmlkbGVMaXN0ZW5lclxuXG4gICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGZhbHNlKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzRnVsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDbGllbnQocGVuZGluZ0l0ZW0pXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBjb25kaXRpb24nKVxuICB9XG5cbiAgX3JlbW92ZShjbGllbnQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZVdoZXJlKHRoaXMuX2lkbGUsIChpdGVtKSA9PiBpdGVtLmNsaWVudCA9PT0gY2xpZW50KVxuXG4gICAgaWYgKHJlbW92ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlbW92ZWQudGltZW91dElkKVxuICAgIH1cblxuICAgIHRoaXMuX2NsaWVudHMgPSB0aGlzLl9jbGllbnRzLmZpbHRlcigoYykgPT4gYyAhPT0gY2xpZW50KVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzXG4gICAgY2xpZW50LmVuZCgoKSA9PiB7XG4gICAgICBjb250ZXh0LmVtaXQoJ3JlbW92ZScsIGNsaWVudClcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbm5lY3QoY2IpIHtcbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ2Fubm90IHVzZSBhIHBvb2wgYWZ0ZXIgY2FsbGluZyBlbmQgb24gdGhlIHBvb2wnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRvIGNvbm5lY3QgYSBuZXcgY2xpZW50LCBkb24ndCBkbyBzb1xuICAgIGlmICh0aGlzLl9pc0Z1bGwoKSB8fCB0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBpZGxlIGNsaWVudHMgc2NoZWR1bGUgYSBwdWxzZSBpbW1lZGlhdGVseVxuICAgICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5fcHVsc2VRdWV1ZSgpKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcykge1xuICAgICAgICB0aGlzLl9wZW5kaW5nUXVldWUucHVzaChuZXcgUGVuZGluZ0l0ZW0ocmVzcG9uc2UuY2FsbGJhY2spKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSAoZXJyLCByZXMsIGRvbmUpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpZClcbiAgICAgICAgcmVzcG9uc2UuY2FsbGJhY2soZXJyLCByZXMsIGRvbmUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gbmV3IFBlbmRpbmdJdGVtKHF1ZXVlQ2FsbGJhY2spXG5cbiAgICAgIC8vIHNldCBjb25uZWN0aW9uIHRpbWVvdXQgb24gY2hlY2tpbmcgb3V0IGFuIGV4aXN0aW5nIGNsaWVudFxuICAgICAgY29uc3QgdGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBwZW5kaW5nIHdhaXRlcnMgYmVjYXVzZVxuICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byBjYWxsIGl0IHdpdGggYSB0aW1lb3V0IGVycm9yXG4gICAgICAgIHJlbW92ZVdoZXJlKHRoaXMuX3BlbmRpbmdRdWV1ZSwgKGkpID0+IGkuY2FsbGJhY2sgPT09IHF1ZXVlQ2FsbGJhY2spXG4gICAgICAgIHBlbmRpbmdJdGVtLnRpbWVkT3V0ID0gdHJ1ZVxuICAgICAgICByZXNwb25zZS5jYWxsYmFjayhuZXcgRXJyb3IoJ3RpbWVvdXQgZXhjZWVkZWQgd2hlbiB0cnlpbmcgdG8gY29ubmVjdCcpKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKVxuXG4gICAgICBpZiAodGlkLnVucmVmKSB7XG4gICAgICAgIHRpZC51bnJlZigpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BlbmRpbmdRdWV1ZS5wdXNoKHBlbmRpbmdJdGVtKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHRoaXMubmV3Q2xpZW50KG5ldyBQZW5kaW5nSXRlbShyZXNwb25zZS5jYWxsYmFjaykpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBuZXdDbGllbnQocGVuZGluZ0l0ZW0pIHtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgdGhpcy5DbGllbnQodGhpcy5vcHRpb25zKVxuICAgIHRoaXMuX2NsaWVudHMucHVzaChjbGllbnQpXG4gICAgY29uc3QgaWRsZUxpc3RlbmVyID0gbWFrZUlkbGVMaXN0ZW5lcih0aGlzLCBjbGllbnQpXG5cbiAgICB0aGlzLmxvZygnY2hlY2tpbmcgY2xpZW50IHRpbWVvdXQnKVxuXG4gICAgLy8gY29ubmVjdGlvbiB0aW1lb3V0IGxvZ2ljXG4gICAgbGV0IHRpZFxuICAgIGxldCB0aW1lb3V0SGl0ID0gZmFsc2VcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKSB7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ2VuZGluZyBjbGllbnQgZHVlIHRvIHRpbWVvdXQnKVxuICAgICAgICB0aW1lb3V0SGl0ID0gdHJ1ZVxuICAgICAgICAvLyBmb3JjZSBraWxsIHRoZSBub2RlIGRyaXZlciwgYW5kIGxldCBsaWJwcSBkbyBpdHMgdGVhcmRvd25cbiAgICAgICAgY2xpZW50LmNvbm5lY3Rpb24gPyBjbGllbnQuY29ubmVjdGlvbi5zdHJlYW0uZGVzdHJveSgpIDogY2xpZW50LmVuZCgpXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpXG4gICAgfVxuXG4gICAgdGhpcy5sb2coJ2Nvbm5lY3RpbmcgbmV3IGNsaWVudCcpXG4gICAgY2xpZW50LmNvbm5lY3QoKGVycikgPT4ge1xuICAgICAgaWYgKHRpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGlkKVxuICAgICAgfVxuICAgICAgY2xpZW50Lm9uKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5sb2coJ2NsaWVudCBmYWlsZWQgdG8gY29ubmVjdCcsIGVycilcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBkZWFkIGNsaWVudCBmcm9tIG91ciBsaXN0IG9mIGNsaWVudHNcbiAgICAgICAgdGhpcy5fY2xpZW50cyA9IHRoaXMuX2NsaWVudHMuZmlsdGVyKChjKSA9PiBjICE9PSBjbGllbnQpXG4gICAgICAgIGlmICh0aW1lb3V0SGl0KSB7XG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIHRlcm1pbmF0ZWQgZHVlIHRvIGNvbm5lY3Rpb24gdGltZW91dCcsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBjbGllbnQgd29u4oCZdCBiZSByZWxlYXNlZCwgc28gbW92ZSBvbiBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLl9wdWxzZVF1ZXVlKClcblxuICAgICAgICBpZiAoIXBlbmRpbmdJdGVtLnRpbWVkT3V0KSB7XG4gICAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIE5PT1ApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nKCduZXcgY2xpZW50IGNvbm5lY3RlZCcpXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgIT09IDApIHtcbiAgICAgICAgICBjb25zdCBtYXhMaWZldGltZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlbmRpbmcgY2xpZW50IGR1ZSB0byBleHBpcmVkIGxpZmV0aW1lJylcbiAgICAgICAgICAgIHRoaXMuX2V4cGlyZWQuYWRkKGNsaWVudClcbiAgICAgICAgICAgIGNvbnN0IGlkbGVJbmRleCA9IHRoaXMuX2lkbGUuZmluZEluZGV4KChpZGxlSXRlbSkgPT4gaWRsZUl0ZW0uY2xpZW50ID09PSBjbGllbnQpXG4gICAgICAgICAgICBpZiAoaWRsZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9hY3F1aXJlQ2xpZW50KFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICBuZXcgUGVuZGluZ0l0ZW0oKGVyciwgY2xpZW50LCBjbGllbnRSZWxlYXNlKSA9PiBjbGllbnRSZWxlYXNlKCkpLFxuICAgICAgICAgICAgICAgIGlkbGVMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyAqIDEwMDApXG5cbiAgICAgICAgICBtYXhMaWZldGltZVRpbWVvdXQudW5yZWYoKVxuICAgICAgICAgIGNsaWVudC5vbmNlKCdlbmQnLCAoKSA9PiBjbGVhclRpbWVvdXQobWF4TGlmZXRpbWVUaW1lb3V0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlQ2xpZW50KGNsaWVudCwgcGVuZGluZ0l0ZW0sIGlkbGVMaXN0ZW5lciwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gYWNxdWlyZSBhIGNsaWVudCBmb3IgYSBwZW5kaW5nIHdvcmsgaXRlbVxuICBfYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGlzTmV3KSB7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjbGllbnQpXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdhY3F1aXJlJywgY2xpZW50KVxuXG4gICAgY2xpZW50LnJlbGVhc2UgPSB0aGlzLl9yZWxlYXNlT25jZShjbGllbnQsIGlkbGVMaXN0ZW5lcilcblxuICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG5cbiAgICBpZiAoIXBlbmRpbmdJdGVtLnRpbWVkT3V0KSB7XG4gICAgICBpZiAoaXNOZXcgJiYgdGhpcy5vcHRpb25zLnZlcmlmeSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5KGNsaWVudCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nSXRlbS5jYWxsYmFjayhlcnIsIHVuZGVmaW5lZCwgTk9PUClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayh1bmRlZmluZWQsIGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayh1bmRlZmluZWQsIGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ldyAmJiB0aGlzLm9wdGlvbnMudmVyaWZ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnkoY2xpZW50LCBjbGllbnQucmVsZWFzZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBfcmVsZWFzZSBhbmQgdGhyb3dzIGlmIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICBfcmVsZWFzZU9uY2UoY2xpZW50LCBpZGxlTGlzdGVuZXIpIHtcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZVxuXG4gICAgcmV0dXJuIChlcnIpID0+IHtcbiAgICAgIGlmIChyZWxlYXNlZCkge1xuICAgICAgICB0aHJvd09uRG91YmxlUmVsZWFzZSgpXG4gICAgICB9XG5cbiAgICAgIHJlbGVhc2VkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVsZWFzZShjbGllbnQsIGlkbGVMaXN0ZW5lciwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbGVhc2UgYSBjbGllbnQgYmFjayB0byB0aGUgcG9sbCwgaW5jbHVkZSBhbiBlcnJvclxuICAvLyB0byByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICBfcmVsZWFzZShjbGllbnQsIGlkbGVMaXN0ZW5lciwgZXJyKSB7XG4gICAgY2xpZW50Lm9uKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcblxuICAgIGNsaWVudC5fcG9vbFVzZUNvdW50ID0gKGNsaWVudC5fcG9vbFVzZUNvdW50IHx8IDApICsgMVxuXG4gICAgdGhpcy5lbWl0KCdyZWxlYXNlJywgZXJyLCBjbGllbnQpXG5cbiAgICAvLyBUT0RPKGJtYyk6IGV4cG9zZSBhIHByb3BlciwgcHVibGljIGludGVyZmFjZSBfcXVlcnlhYmxlIGFuZCBfZW5kaW5nXG4gICAgaWYgKGVyciB8fCB0aGlzLmVuZGluZyB8fCAhY2xpZW50Ll9xdWVyeWFibGUgfHwgY2xpZW50Ll9lbmRpbmcgfHwgY2xpZW50Ll9wb29sVXNlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heFVzZXMpIHtcbiAgICAgIGlmIChjbGllbnQuX3Bvb2xVc2VDb3VudCA+PSB0aGlzLm9wdGlvbnMubWF4VXNlcykge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGV4cGVuZGVkIGNsaWVudCcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUoY2xpZW50LCB0aGlzLl9wdWxzZVF1ZXVlLmJpbmQodGhpcykpXG4gICAgfVxuXG4gICAgY29uc3QgaXNFeHBpcmVkID0gdGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHRoaXMubG9nKCdyZW1vdmUgZXhwaXJlZCBjbGllbnQnKVxuICAgICAgdGhpcy5fZXhwaXJlZC5kZWxldGUoY2xpZW50KVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZShjbGllbnQsIHRoaXMuX3B1bHNlUXVldWUuYmluZCh0aGlzKSlcbiAgICB9XG5cbiAgICAvLyBpZGxlIHRpbWVvdXRcbiAgICBsZXQgdGlkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcyAmJiB0aGlzLl9pc0Fib3ZlTWluKCkpIHtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGlkbGUgY2xpZW50JylcbiAgICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudCwgdGhpcy5fcHVsc2VRdWV1ZS5iaW5kKHRoaXMpKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgICAvLyBhbGxvdyBOb2RlIHRvIGV4aXQgaWYgdGhpcyBpcyBhbGwgdGhhdCdzIGxlZnRcbiAgICAgICAgdGlkLnVucmVmKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgY2xpZW50LnVucmVmKClcbiAgICB9XG5cbiAgICB0aGlzLl9pZGxlLnB1c2gobmV3IElkbGVJdGVtKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aWQpKVxuICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICB9XG5cbiAgcXVlcnkodGV4dCwgdmFsdWVzLCBjYikge1xuICAgIC8vIGd1YXJkIGNsYXVzZSBhZ2FpbnN0IHBhc3NpbmcgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIHRleHQpXG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCdQYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBwb29sLnF1ZXJ5IGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgcGxhaW4gdGV4dCBxdWVyeSB3aXRob3V0IHZhbHVlc1xuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHZhbHVlc1xuICAgICAgdmFsdWVzID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY2IgPSByZXNwb25zZS5jYWxsYmFja1xuXG4gICAgdGhpcy5jb25uZWN0KChlcnIsIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBsZXQgY2xpZW50UmVsZWFzZWQgPSBmYWxzZVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudFJlbGVhc2VkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50UmVsZWFzZWQgPSB0cnVlXG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBjbGllbnQub25jZSgnZXJyb3InLCBvbkVycm9yKVxuICAgICAgdGhpcy5sb2coJ2Rpc3BhdGNoaW5nIHF1ZXJ5JylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWVudC5xdWVyeSh0ZXh0LCB2YWx1ZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKCdxdWVyeSBkaXNwYXRjaGVkJylcbiAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgICBpZiAoY2xpZW50UmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZWxlYXNlZCA9IHRydWVcbiAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXNwb25zZS5yZXN1bHRcbiAgfVxuXG4gIGVuZChjYikge1xuICAgIHRoaXMubG9nKCdlbmRpbmcnKVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYWxsZWQgZW5kIG9uIHBvb2wgbW9yZSB0aGFuIG9uY2UnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cbiAgICB0aGlzLmVuZGluZyA9IHRydWVcbiAgICBjb25zdCBwcm9taXNlZCA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIHRoaXMuX2VuZENhbGxiYWNrID0gcHJvbWlzZWQuY2FsbGJhY2tcbiAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgICByZXR1cm4gcHJvbWlzZWQucmVzdWx0XG4gIH1cblxuICBnZXQgd2FpdGluZ0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nUXVldWUubGVuZ3RoXG4gIH1cblxuICBnZXQgaWRsZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9pZGxlLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGV4cGlyZWRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5yZWR1Y2UoKGFjYywgY2xpZW50KSA9PiBhY2MgKyAodGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KSA/IDEgOiAwKSwgMClcbiAgfVxuXG4gIGdldCB0b3RhbENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiTk9PUCIsInJlbW92ZVdoZXJlIiwibGlzdCIsInByZWRpY2F0ZSIsImkiLCJmaW5kSW5kZXgiLCJ1bmRlZmluZWQiLCJzcGxpY2UiLCJJZGxlSXRlbSIsImNvbnN0cnVjdG9yIiwiY2xpZW50IiwiaWRsZUxpc3RlbmVyIiwidGltZW91dElkIiwiUGVuZGluZ0l0ZW0iLCJjYWxsYmFjayIsInRocm93T25Eb3VibGVSZWxlYXNlIiwiRXJyb3IiLCJwcm9taXNpZnkiLCJQcm9taXNlIiwicmVzdWx0IiwicmVqIiwicmVzIiwiY2IiLCJlcnIiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2F0Y2giLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1ha2VJZGxlTGlzdGVuZXIiLCJwb29sIiwicmVtb3ZlTGlzdGVuZXIiLCJvbiIsImxvZyIsIl9yZW1vdmUiLCJlbWl0IiwiUG9vbCIsIm9wdGlvbnMiLCJDbGllbnQiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwicGFzc3dvcmQiLCJzc2wiLCJrZXkiLCJtYXgiLCJwb29sU2l6ZSIsIm1pbiIsIm1heFVzZXMiLCJJbmZpbml0eSIsImFsbG93RXhpdE9uSWRsZSIsIm1heExpZmV0aW1lU2Vjb25kcyIsImdsb2JhbCIsImlkbGVUaW1lb3V0TWlsbGlzIiwiX2NsaWVudHMiLCJfaWRsZSIsIl9leHBpcmVkIiwiV2Vha1NldCIsIl9wZW5kaW5nUXVldWUiLCJfZW5kQ2FsbGJhY2siLCJlbmRpbmciLCJlbmRlZCIsIl9pc0Z1bGwiLCJsZW5ndGgiLCJfaXNBYm92ZU1pbiIsIl9wdWxzZVF1ZXVlIiwic2xpY2UiLCJtYXAiLCJpdGVtIiwicGVuZGluZ0l0ZW0iLCJzaGlmdCIsImlkbGVJdGVtIiwicG9wIiwiY2xlYXJUaW1lb3V0IiwicmVmIiwiX2FjcXVpcmVDbGllbnQiLCJuZXdDbGllbnQiLCJyZW1vdmVkIiwiZmlsdGVyIiwiYyIsImNvbnRleHQiLCJlbmQiLCJjb25uZWN0IiwicmVzcG9uc2UiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjb25uZWN0aW9uVGltZW91dE1pbGxpcyIsInB1c2giLCJxdWV1ZUNhbGxiYWNrIiwiZG9uZSIsInRpZCIsInNldFRpbWVvdXQiLCJ0aW1lZE91dCIsInVucmVmIiwidGltZW91dEhpdCIsImNvbm5lY3Rpb24iLCJzdHJlYW0iLCJkZXN0cm95IiwiY2F1c2UiLCJtYXhMaWZldGltZVRpbWVvdXQiLCJhZGQiLCJpZGxlSW5kZXgiLCJjbGllbnRSZWxlYXNlIiwib25jZSIsImlzTmV3IiwicmVsZWFzZSIsIl9yZWxlYXNlT25jZSIsInZlcmlmeSIsInJlbGVhc2VkIiwiX3JlbGVhc2UiLCJfcG9vbFVzZUNvdW50IiwiX3F1ZXJ5YWJsZSIsIl9lbmRpbmciLCJiaW5kIiwiaXNFeHBpcmVkIiwiaGFzIiwiZGVsZXRlIiwicXVlcnkiLCJ0ZXh0IiwidmFsdWVzIiwic2V0SW1tZWRpYXRlIiwiY2xpZW50UmVsZWFzZWQiLCJvbkVycm9yIiwicHJvbWlzZWQiLCJ3YWl0aW5nQ291bnQiLCJpZGxlQ291bnQiLCJleHBpcmVkQ291bnQiLCJyZWR1Y2UiLCJhY2MiLCJ0b3RhbENvdW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../database/node_modules/pg-pool/index.js\n");

/***/ })

};
;